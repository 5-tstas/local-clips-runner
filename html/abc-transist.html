<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>A→B→C • Tech-News Transitions + WebM</title>
<style>
  :root { --w:1280; --h:720; --accent:#3aa3ff; }
  body{margin:0;background:#0b0f13;color:#e7eef5;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;display:flex;flex-direction:column;align-items:center;gap:14px;padding:16px}
  .panel{background:#0f141b;border:1px solid #1e2a36;border-radius:12px;padding:12px;display:grid;grid-template-columns:repeat(12,1fr);gap:10px;align-items:center;max-width:1200px;width:100%}
  .panel>*{min-width:0}
  .panel label{font-size:13px;color:#c9d6e2}
  input[type="file"]{color:#c9d6e2}
  input[type="number"],select{background:#0b0f13;color:#e7eef5;border:1px solid #1e2a36;border-radius:8px;padding:8px}
  button{background:var(--accent);color:#001222;border:0;border-radius:10px;padding:10px 14px;font-weight:700;cursor:pointer}
  button:disabled{opacity:.6;cursor:not-allowed}
  .status{grid-column: span 12; color:#9bd1ff; font-size:13px}
  .stageWrap{width:1280px;max-width:calc(100vw - 32px);aspect-ratio:16/9;background:#000;border-radius:12px;box-shadow:0 0 0 1px #1e2a36,0 12px 40px rgba(0,0,0,.5);position:relative;overflow:hidden}
  canvas{width:100%;height:100%;display:block}
  .note{color:#97a9bb;font-size:12px}
  .row{display:flex;gap:10px;align-items:center}
</style>
<!-- общие утилиты записи WebM -->
<script type="module" src="./js/recorder.js"></script>
<!-- опциональный фиксер длительности (даже заглушка не повредит) -->
<script src="./vendor/webm-duration-fix.min.js"></script>

</head>
<body>
  <div class="panel">
    <div class="row" style="grid-column: span 6">
      <label>A <input id="fA" type="file" accept="image/*"></label>
      <label>B <input id="fB" type="file" accept="image/*"></label>
      <label>C <input id="fC" type="file" accept="image/*"></label>
    </div>

    <div class="row" style="grid-column: span 6">
      <label>Масштаб: 
        <select id="fitMode">
          <option value="contain">contain (без обрезки)</option>
          <option value="cover">cover (с обрезкой)</option>
        </select>
      </label>
      <label>FPS:
        <input id="fps" type="number" value="30" min="15" max="60" step="1">
      </label>
    </div>

    <div class="row" style="grid-column: span 12; flex-wrap:wrap">
      <label>A сек: <input id="durA" type="number" value="3.3" min="0.5" max="20" step="0.1"></label>
      <label>B сек: <input id="durB" type="number" value="3.3" min="0.5" max="20" step="0.1"></label>
      <label>C сек: <input id="durC" type="number" value="3.4" min="0.5" max="20" step="0.1"></label>
      <span class="note">По умолчанию суммарно ≈ 10 сек. Переходы «лежат» внутри этих длительностей (последние ~0.6с каждого блока).</span>
    </div>

    <div class="row" style="grid-column: span 12; flex-wrap:wrap">
      <label>Переход A→B:
        <select id="tAB">
          <option value="news">AI news swipe (киан)</option>
          <option value="cross">Crossfade</option>
          <option value="slide">Slide-left</option>
        </select>
      </label>
      <label>Переход B→C:
        <select id="tBC">
          <option value="cross">Crossfade + лёгкий glitch</option>
          <option value="news">AI news swipe (киан)</option>
          <option value="slide">Slide-left</option>
        </select>
      </label>
    </div>

    <div class="row" style="grid-column: span 12">
      <button id="previewBtn">▶︎ Предпросмотр</button>
      <button id="exportBtn">● Экспорт WebM</button>
      <span class="note">Экспорт работает через <code>MediaRecorder</code> (лучше в Chrome).</span>
    </div>

    <div class="status" id="status">Готово</div>
  </div>

  <div class="stageWrap">
    <canvas id="stage" width="1280" height="720"></canvas>
  </div>

<script type="module">
import { startRecorder, stopAndDownload, bindGlobalExport, markStage } from './js/recorder.js';

markStage('goto', { page: 'abc', href: location.href });
markStage('init', { page: 'abc' });

/* ===== Helpers ===== */
const $ = id => document.getElementById(id);
const canvas = $('stage'), ctx = canvas.getContext('2d', { alpha:false });
function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }

function fileToURL(file){ return URL.createObjectURL(file); }
function preload(url){ return new Promise((res,rej)=>{ const i=new Image(); i.onload=()=>res(i); i.onerror=rej; i.src=url; }); }

function drawImageFit(ctx, img, mode='contain', zoom=1){
  const W = canvas.width, H = canvas.height;
  const w = img.naturalWidth || img.width, h = img.naturalHeight || img.height;
  const s = (mode==='cover') ? Math.max(W/w, H/h) : Math.min(W/w, H/h);
  const dw = Math.floor(w*s*zoom), dh = Math.floor(h*s*zoom);
  const dx = Math.floor((W-dw)/2), dy = Math.floor((H-dh)/2);
  ctx.drawImage(img, dx, dy, dw, dh);
}

function drawGridOverlay(alpha=0.06){
  const W=canvas.width, H=canvas.height;
  ctx.save(); ctx.globalAlpha = alpha; ctx.strokeStyle = '#56d0ff'; ctx.lineWidth = 1;
  for(let x=0; x<=W; x+=64){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); }
  for(let y=0; y<=H; y+=64){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); }
  ctx.restore();
}

function drawNoiseOverlay(strength=0.06){
  const W=canvas.width, H=canvas.height;
  ctx.save(); ctx.globalAlpha = strength; ctx.fillStyle = '#9be3ff';
  for(let i=0;i<40;i++){
    const w = 20 + Math.random()*120;
    const h = 1 + Math.random()*3;
    const x = Math.random()*W, y = Math.random()*H;
    ctx.fillRect(x,y,w,h);
  }
  ctx.restore();
}

/* Transitions */
function transCross(fromImg, toImg, p, fit, zoomFrom=1, zoomTo=1){
  drawImageFit(ctx, fromImg, fit, zoomFrom);
  ctx.globalAlpha = p; drawImageFit(ctx, toImg, fit, zoomTo); ctx.globalAlpha = 1;
}

function transSlideLeft(fromImg, toImg, p, fit){
  const W=canvas.width, H=canvas.height;
  // base
  drawImageFit(ctx, fromImg, fit, 1);
  // slide to
  ctx.save();
  const x = W * (1-p); //  from right -> left
  ctx.translate(x, 0);
  drawImageFit(ctx, toImg, fit, 1);
  ctx.restore();
  // slight shadow edge
  const g = ctx.createLinearGradient(x-16,0,x,0);
  g.addColorStop(0,'rgba(0,0,0,0.3)'); g.addColorStop(1,'rgba(0,0,0,0)');
  ctx.fillStyle = g; ctx.fillRect(x-16,0,16,H);
}

function transNewsSwipe(fromImg, toImg, p, fit){
  const W=canvas.width, H=canvas.height;
  // base
  drawImageFit(ctx, fromImg, fit, 1);
  // reveal to with wipe
  ctx.save();
  ctx.beginPath(); ctx.rect(0,0,W*p,H); ctx.clip();
  drawImageFit(ctx, toImg, fit, 1);
  ctx.restore();
  // cyan bar (accent edge)
  const x = W*p;
  const barW = 18;
  const g = ctx.createLinearGradient(x-2,0,x+barW,0);
  g.addColorStop(0,'rgba(58,163,255,0.0)');
  g.addColorStop(0.2,'rgba(58,163,255,0.5)');
  g.addColorStop(1,'rgba(58,163,255,0.0)');
  ctx.fillStyle = g; ctx.fillRect(x-2,0,barW,H);
  // grid + spark noise for tech feel
  drawGridOverlay(0.05 + 0.05*Math.sin(p*Math.PI));
  drawNoiseOverlay(0.03);
}

/* Main draw */
function drawFrame(t, imgs, opts){
  const { A,B,C, transAB, transBC, fit } = opts;
  const W=canvas.width, H=canvas.height;
  const tAB = 0.6, tBC = 0.6; // внутри блоков

  ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);

  if (t < A){
    // A segment with slight ken-burns
    const z = 1 + 0.02*(t/A);
    drawImageFit(ctx, imgs.a, fit, z);
    if (t > A - tAB){
      const p = (t - (A - tAB)) / tAB;
      if (transAB==='cross') transCross(imgs.a, imgs.b, p, fit, z, 1);
      else if (transAB==='slide') transSlideLeft(imgs.a, imgs.b, p, fit);
      else transNewsSwipe(imgs.a, imgs.b, p, fit);
    }
    return;
  }
  if (t < A+B){
    const tb = t - A;
    const z = 1 + 0.01*(tb/B);
    drawImageFit(ctx, imgs.b, fit, z);
    if (tb > B - tBC){
      const p = (tb - (B - tBC)) / tBC;
      if (transBC==='cross'){ transCross(imgs.b, imgs.c, p, fit, z, 1); drawNoiseOverlay(0.04*p); }
      else if (transBC==='slide') transSlideLeft(imgs.b, imgs.c, p, fit);
      else transNewsSwipe(imgs.b, imgs.c, p, fit);
    }
    return;
  }
  // C segment
  const tc = t - (A+B);
  const z = 1 + 0.008*(tc/C);
  drawImageFit(ctx, imgs.c, fit, z);
}

/* Playback / Export */
async function loadImages(){
  const fa=$('fA').files[0], fb=$('fB').files[0], fc=$('fC').files[0];
  if(!fa||!fb||!fc){ throw new Error('Загрузите три изображения'); }
  const [a,b,c] = await Promise.all([preload(fileToURL(fa)), preload(fileToURL(fb)), preload(fileToURL(fc))]);
  return { a,b,c };
}

function getOpts(){
  const A=parseFloat($('durA').value||'3.3');
  const B=parseFloat($('durB').value||'3.3');
  const C=parseFloat($('durC').value||'3.4');
  return {
    A,B,C,
    fit: $('fitMode').value,
    transAB: $('tAB').value,
    transBC: $('tBC').value,
    fps: clamp(parseInt($('fps').value||'30',10), 15, 60),
    total: A+B+C
  };
}

let previewRunning=false;

function playTransition(imgs, opts, maybeOptions){
  let shouldContinue = () => true;
  let onFrame;
  if (typeof maybeOptions === 'function') {
    shouldContinue = maybeOptions;
  } else if (maybeOptions && typeof maybeOptions === 'object') {
    shouldContinue = maybeOptions.shouldContinue || shouldContinue;
    onFrame = maybeOptions.onFrame;
  }
  return new Promise((resolve) => {
    const start = performance.now();
    const totalMs = opts.total * 1000;
    const frame = (now) => {
      if (!shouldContinue()) { resolve(); return; }
      const elapsed = now - start;
      const t = Math.min(opts.total, elapsed / 1000);
      drawFrame(t, imgs, opts);
      if (onFrame) {
        try { onFrame({ elapsedMs: elapsed, t }); } catch (err) { console.error(err); }
      }
      if (elapsed >= totalMs) {
        resolve();
        return;
      }
      requestAnimationFrame(frame);
    };
    drawFrame(0, imgs, opts);
    if (onFrame) {
      try { onFrame({ elapsedMs: 0, t: 0 }); } catch (err) { console.error(err); }
    }
    requestAnimationFrame(frame);
  });
}

async function preview(){
  if(previewRunning) return;
  previewRunning=true;
  window.__CLIP_DONE__ = false;
  try{
    $('status').textContent='Предпросмотр…';
    const imgs = await loadImages();
    const opts = getOpts();
    await playTransition(imgs, opts, {
      shouldContinue: () => previewRunning,
    });
    if (previewRunning) {
      window.__CLIP_DONE__ = true;
      $('status').textContent='Готово';
    }
  } catch(e){
    console.error(e);
    $('status').textContent='Ошибка: ' + e.message;
  } finally{
    previewRunning=false;
  }
}

async function performExport(){
  window.__CLIP_DONE__ = false;
  $('exportBtn').disabled=true;
  $('status').textContent='Экспорт WebM…';
  try{
    const imgs = await loadImages();
    const opts = getOpts();
    drawFrame(0, imgs, opts);
    const recCtx = startRecorder(canvas, { fps: opts.fps, vbr: 5_000_000 });
    recCtx.rec.start();
    recCtx.noteFrame({ page: 'abc', stage: 'prime' });
    await playTransition(imgs, opts, {
      shouldContinue: () => true,
      onFrame: ({ t }) => recCtx.noteFrame({ page: 'abc', t }),
    });
    await stopAndDownload(recCtx, 'abc_transition.webm', { finalDelayMs: 300 });
    $('status').textContent = 'Готово: скачан WebM';
    window.__CLIP_DONE__ = true;
  } catch(e){
    console.error(e);
    $('status').textContent='Экспорт не удался: '+e.message;
  } finally{
    $('exportBtn').disabled=false;
  }
}

/* Bindings */
$('previewBtn').addEventListener('click', ()=>{ previewRunning=false; preview(); });
bindGlobalExport(performExport);
</script>
<script>
(async () => {
  const qs = new URLSearchParams(location.search);
  const b64 = qs.get('data') || '';
  let STATE = {};
  if (b64) { try { STATE = JSON.parse(atob(b64)); } catch(e){} }
  window.STATE = STATE;
  if (document.fonts?.ready) { try { await document.fonts.ready; } catch(_){} }

  // Если у вас есть свои init-функции — вызывайте их здесь:
  if (window.initOverlay) window.initOverlay(STATE);
  if (window.initChat) window.initChat(STATE);
  if (window.initABC) window.initABC(STATE);
})();
</script>
<script>
/* Автостарт предпросмотра/анимации после загрузки страницы */
(function autoStart() {
  const startFns = ['preview','runPreview','start','startPreview','play'];
  for (const fn of startFns) {
    if (typeof window[fn] === 'function') {
      try { window[fn](window.STATE); return; } catch(e) {}
    }
  }
  // запасной вариант — клик по типовым кнопкам «Предпросмотр»
  const selectors = ['#btnPreview', '#preview', '[data-action="preview"]', '.preview'];
  for (const sel of selectors) {
    const el = document.querySelector(sel);
    if (el) { el.click(); return; }
  }
  // если ничего не найдено, повторим попытку чуть позже (DOM может не успеть)
  setTimeout(autoStart, 120);
})();
</script>

</body>
</html>

