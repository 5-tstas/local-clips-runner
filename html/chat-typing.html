<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Chat Typing — Markdown → печать, предпросмотр и экспорт WebM</title>
<style>
  :root{--accent:#3aa3ff;--ui:#0f141b;--line:#1e2a36;--bg:#0b0f13}
  html,body{height:100%}
  body{margin:0;background:var(--bg);color:#e8edf2;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
       display:flex;flex-direction:column;align-items:center;gap:14px;padding:16px}
  .panel{background:var(--ui);border:1px solid var(--line);border-radius:12px;padding:12px;display:grid;
         grid-template-columns:repeat(12,1fr);gap:10px;max-width:1280px;width:100%}
  .group{border:1px solid var(--line);border-radius:10px;padding:10px;grid-column:span 12}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  label{font-size:13px;color:#c9d6e2}
  input,textarea,select{background:#0b0f13;color:#e8edf2;border:1px solid var(--line);border-radius:8px;padding:8px;font-size:14px}
  textarea{width:100%}
  input[type="number"]{width:90px}
  button{background:var(--accent);color:#001222;border:0;border-radius:10px;padding:10px 14px;font-weight:700;cursor:pointer}
  button:disabled{opacity:.6;cursor:not-allowed}
  .status{grid-column:span 12;color:#9bd1ff;font-size:13px}
  .stage{width:1280px;max-width:calc(100vw - 32px);aspect-ratio:16/9;background:#000;border-radius:12px;
         box-shadow:0 0 0 1px var(--line),0 12px 40px rgba(0,0,0,.5);overflow:hidden}
  canvas{width:100%;height:100%;display:block}
  .title{font-weight:700;color:#cfe6ff}
</style>
<!-- общие утилиты записи WebM -->
<script type="module" src="./js/recorder.js"></script>
<!-- опциональный фиксер длительности (даже заглушка не повредит) -->
<script src="./vendor/webm-duration-fix.min.js"></script>

</head>
<body>
  <div class="panel">
    <div class="group">
      <div class="row">
        <label style="flex:1">Промт
          <input id="prompt" type="text" placeholder="Объясни простыми словами, как работает трансформер">
        </label>
        <label>Скорость промта (симв/с) <input id="cpsPrompt" type="number" value="14" min="4" max="80"></label>
        <label>«Думает» (сек) <input id="thinkSec" type="number" value="2" min="0" max="30"></label>
      </div>
      <label>Ответ (Markdown)
        <textarea id="answer" rows="8" placeholder="# Заголовок
## Подзаголовок
- Пункт 1
- **Жирный** и *курсив*
Текст с `кодом` и [ссылкой](https://example.com)"></textarea>
      </label>
      <div class="row">
        <label>Скорость ответа (симв/с) <input id="cpsAnswer" type="number" value="20" min="4" max="120"></label>
        <label>Пауза после . ! ? … (мс) <input id="pauseSentence" type="number" value="220" min="0" max="1500"></label>
        <label>Пауза после , ; : (мс) <input id="pauseComma" type="number" value="110" min="0" max="1000"></label>
        <label>FPS <input id="fps" type="number" value="30" min="15" max="60" style="width:70px"></label>
        <label class="row" style="gap:6px"><input id="soundOn" type="checkbox"> Включить «тап-тап»</label>
      </div>
    </div>

    <div class="group">
      <div class="row">
        <button id="previewBtn">▶︎ Предпросмотр</button>
        <button id="exportBtn">● Экспорт WebM</button>
      </div>
      <div class="status" id="status">Готово</div>
    </div>
  </div>

  <div class="stage"><canvas id="cv" width="1280" height="720"></canvas></div>

<script type="module">
import { startRecorder, stopAndDownload, bindGlobalExport } from './js/recorder.js';
/* ---------- Утилиты ---------- */
const $=id=>document.getElementById(id);
const sleep=ms=>new Promise(r=>setTimeout(r,ms));
function setStatus(s){ const el=$('status'); if(el) el.textContent=s; }

/* ---------- Markdown → строки (очень простой) ---------- */
function mdToBlocks(md){
  const lines=(md||'').replace(/\r\n/g,'\n').replace(/\r/g,'\n').split('\n');
  const out=[];
  let i=0, num=1;
  for (const raw of lines){
    let line=raw.trimEnd();
    if (!line){ out.push({type:'sp',text:''}); continue; }
    if (line.startsWith('```')) { out.push({type:'codeFence',text:'‒‒‒ code ‒‒‒'}); continue; }
    if (line.startsWith('## ')){ out.push({type:'h2', text:line.slice(3)}); continue; }
    if (line.startsWith('# ')) { out.push({type:'h1', text:line.slice(2)}); continue; }
    if (/^(\-|\*)\s+/.test(line)){ out.push({type:'ul', text:line.replace(/^(\-|\*)\s+/, '')}); continue; }
    if (/^\d+[.)]\s+/.test(line)){ out.push({type:'ol', text:line.replace(/^\d+[.)]\s+/, '') , idx:num++}); continue; }
    // inline: **b**, *i*, `code`, [text](url) → упростим до текста
    line=line.replace(/\*\*(.+?)\*\*/g,'$1').replace(/\*(.+?)\*/g,'$1').replace(/`(.+?)`/g,'$1').replace(/\[(.+?)\]\((.+?)\)/g,'$1');
    out.push({type:'p', text:line});
  }
  return out;
}

/* ---------- Разметка/рендер чата ---------- */
const W=1280,H=720; const cv=$('cv'); const ctx=cv.getContext('2d',{alpha:false});
function bubble(ctx,x,y,w,txtLines,style){
  // стиль
  ctx.save();
  const pad=16, r=16;
  // фон пузыря
  ctx.fillStyle=style.bg;
  roundRect(ctx,x,y,w,style.boxH,r); ctx.fill();
  // текст
  ctx.fillStyle=style.color; ctx.textBaseline='top';
  let yy=y+pad, maxW=w-2*pad;
  for(const ln of txtLines){
    ctx.font = fontFor(ln.type, style);
    const chunks = wrap(ln.render, ctx, maxW);
    for(const ch of chunks){ ctx.fillText(ch, x+pad, yy); yy+=lineHeightFor(ln.type, style); }
  }
  ctx.restore();
}
function roundRect(ctx,x,y,w,h,r){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); }
function fontFor(type, s){
  if (type==='h1') return `700 ${Math.round(s.fs*1.35)}px ${s.font}`;
  if (type==='h2') return `700 ${Math.round(s.fs*1.15)}px ${s.font}`;
  if (type==='ul' || type==='ol') return `400 ${s.fs}px ${s.font}`;
  return `400 ${s.fs}px ${s.font}`;
}
function lineHeightFor(type, s){
  if (type==='h1') return Math.round(s.fs*1.6);
  if (type==='h2') return Math.round(s.fs*1.4);
  return Math.round(s.fs*1.35);
}
function wrap(text, ctx, maxW){
  const words=(text||'').split(/\s+/); const out=[]; let cur='';
  for(const w of words){
    const t=cur?cur+' '+w:w;
    if (ctx.measureText(t).width<=maxW) cur=t;
    else{ if(cur) out.push(cur); cur=w; }
  }
  if(cur) out.push(cur);
  return out;
}

/* ---------- Конфиг/состояние ---------- */
function getCfg(){
  return {
    fps: +$('fps').value||30,
    cpsPrompt: +$('cpsPrompt').value||14,
    cpsAnswer: +$('cpsAnswer').value||20,
    thinkSec: +$('thinkSec').value||2,
    pauseSentence: +$('pauseSentence').value||220,
    pauseComma: +$('pauseComma').value||110,
    soundOn: !!$('soundOn').checked,
    font: 'System UI, -apple-system, Segoe UI, Roboto, Arial',
    fs: 28,
    youBg:'#16212e', youColor:'#cfe6ff',
    aiBg:'#1b1f27', aiColor:'#e8edf2',
    bg:'#0b0f13'
  };
}
function buildState(cfg){
  const prompt = $('prompt').value || '';
  const blocks = mdToBlocks($('answer').value || '');
  return {
    phase: 'prompt',
    promptTxt: prompt,
    blocks,
    pIdx: 0, // символы промта
    aLine: 0, aChar: 0, aPause: 0,
    thinkLeft: Math.max(0, Math.round(cfg.thinkSec*1000)),
    __ts: performance.now()
  };
}

/* ---------- Типографика и звук ---------- */
let tapCtx=null, tapBuf=null;
async function ensureTap(){
  if (tapCtx) return;
  try{
    const AC = window.AudioContext||window.webkitAudioContext;
    tapCtx = new AC();
    const sr=tapCtx.sampleRate, len=sr*0.03, buf=tapCtx.createBuffer(1,len,sr);
    const data=buf.getChannelData(0);
    for(let i=0;i<len;i++){ data[i]=Math.sin(2*Math.PI*300*i/sr)*Math.exp(-6*i/len); }
    tapBuf=buf;
  }catch(e){ tapCtx=null; tapBuf=null; }
}
function playTap(){
  if(!tapCtx||!tapBuf) return;
  const src=tapCtx.createBufferSource();
  src.buffer=tapBuf; src.connect(tapCtx.destination); src.start(0);
}

/* ---------- Рендер кадра ---------- */
function renderFrame(cfg, st){
  ctx.fillStyle=cfg.bg; ctx.fillRect(0,0,W,H);

  // PROMPT bubble (слева)
  const leftX=80, rightX=240, bubbleW= W- leftX - 80;
  const pText = st.promptTxt.slice(0, st.pIdx);
  const pLines = pText? [{type:'p',render:pText}] : [];
  let pBoxH=0;
  if (pLines.length){
    // измерим высоту
    let tmp=0; ctx.font=fontFor('p', cfg);
    for(const ln of pLines){ const chunks=wrap(ln.render, ctx, bubbleW-32); tmp += lineHeightFor('p', cfg)*chunks.length; }
    pBoxH = tmp + 32;
    bubble(ctx, leftX, 80, bubbleW, pLines, {bg:cfg.youBg,color:cfg.youColor,fs:cfg.fs,font:cfg.font,boxH:pBoxH});
  }

  // ANSWER bubble (справа)
  // Собираем отображаемые строки до текущего индекса
  let shown=[];
  for(let i=0;i<st.aLine;i++){ const b=st.blocks[i]; shown.push({...b, render:b.type==='ol'? (b.idx+'. '+b.text) : (b.type==='ul'? ('• '+b.text): b.text)}); }
  if (st.aLine < st.blocks.length){
    const cur = st.blocks[st.aLine];
    const prefix = (cur.type==='ol')? (cur.idx+'. ') : (cur.type==='ul'? '• ' : '');
    const curTxt = prefix + (cur.text||'');
    shown.push({...cur, render: curTxt.slice(0, st.aChar)});
  }

  // измерим высоту ответа
  let aH=0;
  for(const ln of shown){
    const lh=lineHeightFor(ln.type,cfg);
    ctx.font=fontFor(ln.type,cfg);
    const chunks = wrap(ln.render, ctx, bubbleW-32);
    aH += lh * (chunks.length||1);
  }
  if (shown.length) aH += 32;
  const ay = pLines.length? (80 + pBoxH + 18) : 80;
  if (shown.length){
    bubble(ctx, rightX, ay, bubbleW, shown, {bg:cfg.aiBg,color:cfg.aiColor,fs:cfg.fs,font:cfg.font,boxH:aH});
  }
}

/* ---------- Шаг симуляции ---------- */
function step(cfg, st, dt){
  const sent=/[.!?…]/, comma=/[,;:]/;

  if (st.phase==='prompt'){
    // печатаем промт
    const iv = 1000/Math.max(1,cfg.cpsPrompt);
    st.pIdx += Math.max(0, Math.floor(dt/iv));
    if (st.pIdx >= st.promptTxt.length){
      st.pIdx = st.promptTxt.length;
      st.phase = 'think';
    } else {
      if (cfg.soundOn) playTap();
    }
    return;
  }

  if (st.phase==='think'){
    st.thinkLeft -= dt;
    if (st.thinkLeft <= 0){
      st.phase = 'answer';
    }
    return;
  }

  if (st.phase==='answer'){
    const cur = st.blocks[st.aLine];
    if (!cur){ st.phase='done'; return; }
    const baseIv = 1000/Math.max(1,cfg.cpsAnswer);

    if (st.aPause > 0){
      st.aPause -= dt;
      return;
    }

    st.aChar += Math.max(0, Math.floor(dt/baseIv));
    const prefix = (cur.type==='ol')? (cur.idx+'. ') : (cur.type==='ul'? '• ' : '');
    const curTxt = prefix + (cur.text||'');

    // доп. паузы
    const ch = curTxt[st.aChar-1] || '';
    if (sent.test(ch)) st.aPause += cfg.pauseSentence;
    else if (comma.test(ch)) st.aPause += cfg.pauseComma;

    if (st.aChar >= curTxt.length){
      st.aLine += 1;
      st.aChar = 0;
      st.aPause = 0;
      if (st.aLine >= st.blocks.length){
        st.phase='done';
      }
    } else {
      if (cfg.soundOn) playTap();
    }
    return;
  }
}

/* ---------- Предпросмотр ---------- */
let running=false, afId=0;
function runPreview(){
  if (running) return;
  running=true; window.__CLIP_DONE__=false; setStatus('Предпросмотр…');

  const cfg=getCfg(); const st=buildState(cfg);
  let last=performance.now();
  function loop(ts){
    if (!running) return;
    const dt = ts - last; last = ts;
    step(cfg, st, dt);
    renderFrame(cfg, st);
    if (st.phase==='done'){
      running=false; window.__CLIP_DONE__=true;
      setStatus('Готово');
      return;
    }
    afId = requestAnimationFrame(loop);
  }
  afId = requestAnimationFrame(t=>{ last=t; loop(t); });
}

/* ---------- Экспорт ---------- */
async function runExport(outName='chat_typing.webm'){
  if (running) return null;
  running=true; window.__CLIP_DONE__=false; setStatus('Экспорт…');
  const btn=$('exportBtn'); if(btn) btn.disabled=true;

  try{
    const cfg=getCfg(); const st=buildState(cfg);
    renderFrame(cfg, st);

    const fps=30;
    const recCtx=startRecorder(cv,{fps,vbr:5_000_000});
    await new Promise(res=>requestAnimationFrame(()=>{ recCtx.rec.start(); res(); }));

    await new Promise((resolve)=>{
      let last=performance.now();
      function loop(ts){
        if(!running) return;
        const dt=ts-last; last=ts;
        step(cfg, st, dt);
        renderFrame(cfg, st);
        if(st.phase==='done'){ resolve(); return; }
        requestAnimationFrame(loop);
      }
      requestAnimationFrame((ts)=>{ last=ts; loop(ts); });
    });

    const holdFrames = Math.max(1, Math.round(fps * 0.3));
    for(let i=0;i<holdFrames;i++){
      renderFrame(cfg, st);
      await new Promise(res=>requestAnimationFrame(()=>res()));
    }
    const blob=await stopAndDownload(recCtx,outName,{finalDelayMs:350});
    setStatus(`Скачан ${outName}`);
    window.__CLIP_DONE__=true;
    return blob;
  }catch(e){
    console.error(e);
    setStatus('Ошибка экспорта: '+e.message);
    throw e;
  }finally{
    running=false;
    const btn=$('exportBtn'); if(btn) btn.disabled=false;
  }
}

/* ---------- Привязка UI ---------- */
$('previewBtn').addEventListener('click', runPreview);
bindGlobalExport(runExport, 'chat_typing.webm');
window.preview = runPreview;
window.runPreview = runPreview;
window.runExport = runExport;
window.getCfg = getCfg;
window.buildState = buildState;
window.renderFrame = renderFrame;

/* ---------- STATE из ?data= и авто-заполнение ---------- */
(async () => {
  const qs = new URLSearchParams(location.search);
  const b64 = qs.get('data') || '';
  let STATE = {};
  if (b64) { try { STATE = JSON.parse(atob(b64)); } catch(e){} }
  window.STATE = STATE;

  // автозаполнение
  const set = (sel,val) => { const el=document.querySelector(sel); if(!el||val==null) return;
                             el.value = Array.isArray(val) ? val.join('\n\n') : String(val);
                             el.dispatchEvent(new Event('input',{bubbles:true}));
                             el.dispatchEvent(new Event('change',{bubbles:true})); };
  if(STATE.prompt) set('#prompt', STATE.prompt);
  if(STATE.lines)  set('#answer', Array.isArray(STATE.lines)? STATE.lines.join('\n\n') : STATE.lines);
  if(STATE.cpsPrompt) set('#cpsPrompt', STATE.cpsPrompt);
  if(STATE.cpsAnswer) set('#cpsAnswer', STATE.cpsAnswer);
  if(STATE.pauseSentence) set('#pauseSentence', STATE.pauseSentence);
  if(STATE.pauseComma) set('#pauseComma', STATE.pauseComma);
  if(STATE.fps) set('#fps', STATE.fps);
  if(STATE.soundOn===true) $('soundOn').checked = true;

  // первый кадр
  renderFrame(getCfg(), buildState(getCfg()));

  // автозапуск только если не запрещён
  const autostart = (qs.get('autostart') !== '0') && (STATE.autostart !== false);
  if (autostart) runPreview();
})();
</script>
</body>
</html>



